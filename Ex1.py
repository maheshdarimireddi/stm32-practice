# import numpy as np
# import cv2
# import matplotlib.pyplot as plt

# eeprom_hex = "00B0999F000020610004032003E0021C5626618B048D0000190100000000BE334210FFBF13130203F202E1F2D1E1A0C11223F113E0F3D0E2C0E3C1D3C1D4A2D379A631C2EDBB110F332233330012CCEFEEDD00FF2211333222331122EF00BCDD16A62FA22D53A17A433309CA3734313223520C7413BE0320EC00F3009EC52558082EFC9E140EEC5C042E00501FEEF42E03DE07F01B4EF36E000E031E16FEF2FE0710F74E17A0F3BEFF60FB700BB0EB8EF432F3E00BD0E89EF0F0EC700AF2E7400862F8CEF05C04900472FCAEF83C08700022004EFBAC0BC00060FF7EF75E0B5E0762F79EF40E0C1003C2FBCEEC0E0BD0F872F83EF02E04E0FD32F4F0F3CE07D20400F86013FEEC3E0040FC60101EF01EF83EFC3E1790EFAEFC5EFF401360E79CFB90F39E0C3EE81EFBC0FB900BC0E7CEF422F3E00BF0E0CEF4E2F4720440DC6E07B2F42EF3BC03F0FC00F82EF3EC0BE0F800FC0EF77E0780FC32FF1EF34C038EFF72F36EEC0E07FEFFA2FB60EF9E0790FFE4FBB0F3AE0080FCA2F830EC2EFC920BA0FFF20FC0EFEE0810FC5017D0F03E0002000213A0EBFE0080FF900BAEE7AEFBF0F7900C5EF3FEFBE0FF800002EBBEF802F3E00BB0E480F4B2F0600420E0D01B5007A0FB7C139017D2040E039E100013D20FDE037C0FC00C52076EFB7E0F8E0BC20360FC1C1BC00FB20B50F7DE17800FC40790FF6E103008620010FBD00C9017300BA02340FBAE0FD00C001820FC0E0800086023D0F7FE08800B801B90F79E07D003B01850F82E07B00B9013E0FB6007E203A01760F810FC80F8321BC2EC801362FFC0FB6E0BD00402FC30F06E0C400442FC9EF41C083000D203C0F7EE0FDE0020FBFEF09C0C6007F207D0EC2E13900424FFE0FB9E104000B2F860FBE004A00F300B90F40F7B00BE008201FFEFC30082004901FE0F40E08700BC017BEF3EE03F007A01470F84EFC1000020C10F7B003F203C21772F04E0060FC2213D2EC700752F7B0EF6CFFD0FC12F45EEC1C0450FC52F8CEF01C043000B2FBFEEFFE0410FC22FBD0ECAE0860FC42F820E44E0BE00022FBE0F39004600084F840EFF0009016F20B421B20FB6017900BE01BE0F8100430045217BEF7E00C9207C013CEF3CE03D2FBF0103EF80E03D207D20FB0F77E03B2FFB00F10F000F820FBD20F70E84017020350F73E0F7017A203F0F80E14200842047EFFDE0FF010A207E0F7DC0FD00BF2FC00F85E18100BF4FBF0F7DE17800FC403BEFF201012083203E0FF800850032007621350F38E07B200300C30F040002004801010EC40F4E0FC200FE0F3C0FBF0FBE00890EC7EF7F0FFD20BD0F38EFFC2FF920F52F3E003F003A00F72EC200322F360EB5E038007B2F430E82E08400022FC80EC0E0440F8F2F820EFEE0BC0FC02FBE0EC9E0870FFF4FFD0EFDE0F8007C40390F35013E00BF207A0F7700C22031013621F0003600BB00C221BE0000204000C621BF0F80004A013A217CEFBC003E007C0145003F003C00F9013C0FF700B920F521B12FBD007F20BC21B52F810FF12FB50F6FE0B6007A2F820F3CE0FF007F20050F3EE0FF004920780F3BE0FB003C203A0F43E17E00BB20B80F3BE17600F840B40FF001BD213F20BB0FF401402131213641740FF700FB0082217B0FFF0FC300852139EF40004820F820FA0F7C003C007A01030FFF003B013421390FF5007820B720B50FBF0FC0007D20BA0F8400782FBD0EBAE07D00012F480E81E0862F892F8B0F3FEFC6000E203D0E80E04100022FFF0EC9E105004140BA0EFE013B00BF403D0F790105008720040F4100CB0FBB0081207E0F7F0F43004920C20F460F840089213F0F010FC900BC20FC0F3E0FFB207C20C50F820FFB20FA20BC0FB80FFF20BC20BB2F840FC8208220812F8B0FF92F7F0E7BE0BD2F812F860EFFE0840FC020050F3CE0FE004620780F38E0FA00B820780F41E1BE00F841360F78E1B600FD40F90FB901C2210741000F80020A2E7B00004FFA0EFE0EC00004203E0EC20EFE000320B60EF80F01E07220730EF20F732FB6207C0FF40F74207420742F330F77207520762FBE0F452080207E2F4A0F412F460E7FE0830FC52F890E82E0870FC300070F7AE13C004520F50F37E17520B620790FBF0278213841380FB90237217C417A0FFB0284218A41852004024D2F8700CC40460F490FCAE0CC20850F890F46010540BBEFFB2044013720B6EFB7003900F72101003F007921B720FC203A0F81213F20400FCC2F51014C400500070EC52E890D44EF870F060F490DC2EFC60F022FC10EB7E037004020330EB1E073003520330EFDE1BB00F521330F3901B720BF40BD0F3D0149008F210A0F7B01BD0"
# frame_hex = "FFC3FFB8FFBDFFACFFB5FFAAFFB3FFA6FFB2FFA8FFB3FFA5FFBAFFBFFFFEFFF50135001A03CE0006011BFFF0002CFFDC0008FFD6FFF2FFD0FFE9FFD1FFE3FFC4FFB4FFAFFFA7FFADFFAAFFA3FFA0FFA5FFA7FFA1FFA2FFA6FFB6FFBFFFEA00120049027B002003CAFFFC006FFFE3FFFCFFE1FFE7FFD5FFDCFFDAFFD1FFD0FFC7FFBCFFB3FFB6FFA8FFAFFFA7FFB0FFA0FFADFFA5FFB2FFA8FFC4FFD0001800390198010A026F001D0065FFEA0002FFDAFFF5FFD8FFEBFFCDFFE3FFD1FFE3FFC3FFB0FFABFFA3FFA7FFA4FFA2FF9DFFA1FFA2FF9FFFA3FFA6FFC0FFC2001D005F015B01A4005F0119FFF1000EFFDDFFE8FFE1FFD9FFD2FFD4FFD4FFCDFFD0FFC7FFB9FFB3FFB4FFA8FFB2FFA6FFADFF9FFFAFFFA5FFB1FFA9FFC7FFDA006100D40198014D0158FFFE0040FFDBFFFAFFCFFFEEFFCFFFE4FFC5FFDCFFBEFFD8FFBCFFAFFFAAFFA1FFA7FFA4FF9EFF9BFF9CFFA5FF9EFFA4FFA2FFCDFFCE008200D2014E0190000800D4FFD90001FFCEFFDFFFD4FFD1FFC4FFCBFFC3FFBFFFBFFFBCFFB8FFAFFFB4FFA6FFACFFA5FFA8FF9CFFAAFFA4FFB0FFAFFFD1002900C2011F01A10049010BFFC5001DFFBDFFE4FFB7FFD9FFB5FFD1FFB2FFC9FFB2FFCEFFB3FFACFFA8FFA0FFA3FF9FFF9DFF93FF9BFFA1FF9AFFA5FFA30006FFF9011F01260084016EFFBA0082FFB6FFDBFFA8FFC0FFB1FFB1FFABFFB6FFB7FFAFFFB9FFB6FFB5FFADFFB1FFA3FFAAFFA1FFA8FF9CFFACFFA5FFB2FFC6FFFC00AF0118010F0182FFDC00AEFF98FFE2FF98FFBEFF9AFFBBFFA0FFBEFFA6FFC0FFAEFFD5FFC0FFA7FFA2FF9BFF9EFF9BFF98FF93FF99FFA1FF9AFFB6FFA900770047011F0157FFFF0133FF950034FF9DFFB3FF95FFA6FFA4FF9FFFA3FFA8FFB1FFAEFFC5FFC5FFB5FFADFFAFFFA2FFABFFA1FFA7FF9DFFABFFADFFB7FFFF003E0107014A0088015DFFAF006AFF9AFFD0FF9DFFB9FF9AFFB7FF9CFFB7FFA2FFBDFFB2FFDBFFC4FFA8FFA1FF99FF9DFF9EFF95FF93FF98FFA3FF98FFDDFFB900CE009800B3015FFFBE00FEFF960003FF9EFFA8FF96FFA3FFA4FF9AFFA0FFA3FFB0FFADFFC9FFC1FFB2FFAAFFADFFA2FFA9FF9FFFA4FF9BFFAAFFB8FFC30047008200FD01530007011EFFA00029FF94FFC1FF9BFFB5FF99FFB4FF9DFFB3FFA1FFBBFFB1FFD8FFC3FFA2FF9EFF94FF9BFF99FF92FF8FFF96FFA8FF9A0016FFD700DD00CF002A0147FFA300ABFF90FFDAFF9AFFA3FF94FF9FFFA3FF9CFF9BFFA2FFAEFFA9FFBBFFBDFFAFFFADFFB0FFA2FFA7FFA1FFA5FFA0FFAAFFCFFFD6007000B400A20147FFC400D5FF9CFFFCFF98FFBBFF9BFFB2FF98FFB3FF9DFFB2FF9FFFB7FFA9FFBFFFA5FF9EFF9DFF97FF9AFF99FF92FF92FF96FFB7FF990041000200AC00E5FFD60128FF9C005DFF90FFC2FF96FF9DFF8FFF9CFF9FFF98FF9AFF9DFFA9FFA0FFAAFFA4FFB3FFAFFFAEFFA6FFA9FFA4FFA8FFA6FFABFFEEFFF4006900CC00400126FFA80082FF99FFD9FF96FFB4FF9CFFAEFF99FFB2FF9EFFAFFF9EFFB6FFAAFFBEFFA8FFA3FFA0FF97FF9DFF9CFF93FF98FF95FFCDFFA100320026005900E3FFAE00E8FF950012FF8BFFADFF97FF9AFF90FF9AFFA3FF99FF9AFF9DFFAAFFA2FFADFFA9FFB1FFAEFFADFFA8FFA9FFA8FFA7FFB5FFB3FFF6000B003F00C6000200F5FF9F0038FF9BFFC7FF96FFB2FF99FFB1FF9CFFB5FFA4FFB4FFA1FFB5FFAAFFBBFFA7FF9FFF9CFF96FF9DFF99FF95FFA1FF99FFD8FFAB000C0037001B00DAFFA200A3FF98FFE3FF90FFA8FF99FF9BFF97FF9FFFA4FF9BFF99FF9EFFA4FF9DFFA1FFA0FFAFFFB0FFAFFFAAFFAEFFB1FFB0FFC1FFBFFFEB001D000C00CAFFED00BAFFA80008FFA0FFC2FF9EFFB5FFA0FFB1FF9FFFB6FFA8FFB7FFA8FFB5FFAAFFB8FFA5FF9BFF9DFF98FFA0FFA1FF9DFFACFFA4FFD0FFBBFFE9003CFFF000D0FFA30057FF9FFFC9FF92FFA7FF9BFF97FF90FF9AFFA4FF9DFF9CFFA4FFA8FFA0FFA1FFA2FFB4FFB4FFAFFFAAFFB0FFB0FFB8FFBCFFC7FFD4001FFFE700C7FFD6006DFFA7FFEBFFA9FFC0FFA3FFB5FFA2FFAFFF9BFFAEFFA1FFAEFFA3FFB4FFACFFB9FFABFF95FF95FF89FF93FF93FF92FF9AFF99FFB2FFBBFFBD002CFFC900ABFF970011FF9BFFB1FF8DFF9FFF95FF93FF8CFF92FF93FF8AFF8CFF92FF9BFF96FFA0FF9F4DA419597FFF19597FFF19587FFF1958FFC1CD3816C6D79CFFF80009FFFEFFFF189E03E602557FFF189E03E602557FFF0001000100010001000100010001000106567FFF19597FFF19597FFF19587FFFFFC5F4DCCF83D6CA0009FFFDFFFE000100F6003C26C2003A00F6003C26C2003A0001000100010001000100010001000100010001"
# def extract_parameters(eeprom):
#     params = {}
#     def get_signed_word(high_byte, low_byte):
#         val = (high_byte << 8) | low_byte
#         if val & 0x8000:  # negative value
#             val -= 0x10000
#         return val

#     # Convert EEPROM bytes to integer list if needed
#     if isinstance(eeprom, str):
#         eeprom = [int(eeprom[i:i+2], 16) for i in range(0, len(eeprom), 2)]

#     # Example params (for demo, real offsets/gains require datasheet)
#     params['VDD25'] = get_signed_word(eeprom[0], eeprom[1])
#     params['KV_VDD'] = get_signed_word(eeprom[2], eeprom[3])
#     params['PTAT25'] = get_signed_word(eeprom[4], eeprom[5])
#     params['KV_PTAT'] = get_signed_word(eeprom[6], eeprom[7])

# # Example: offsets for first 768 pixels (simplified, use real EEPROM mapping)
#     params['offsets'] = [get_signed_word(eeprom[8+i*2], eeprom[9+i*2]) for i in range(768)]
#     params['gain'] = get_signed_word(eeprom[16], eeprom[17])
#     return params

# def getTa(frame, cal_params):
#     """Calculate ambient temperature (Ta) from PTAT value (simplified)."""
#     ptat = frame[768]  # PTAT usually at frame[768]
#     ptat25 = cal_params['PTAT25']
#     kv_ptat = cal_params['KV_PTAT'] if cal_params['KV_PTAT'] != 0 else 1  # avoid div0

#     ta = (ptat - ptat25) / kv_ptat + 25  # linear approx
#     return ta

# def calculate_pixels(frame, cal_params, ta, emissivity=0.95, tr=25):
#     """Calculate temperature for each pixel (simplified)."""
#     pixels = np.zeros(768)
#     offsets = cal_params['offsets']
#     gain = cal_params['gain'] if cal_params['gain'] != 0 else 1

#     for i in range(768):
#         # Simplified pixel temp formula (real MLX90640 is more complex)
#         # To = (IR_raw - offset) / gain + Ta correction
#         pixels[i] = (frame[i] - offsets[i]) / gain + ta

#     # Reshape to 24x32 grid
#     grid = pixels.reshape((24, 32))
#     return grid

# eeprom_bytes = [int(eeprom_hex[i:i+2], 16) for i in range(0, len(eeprom_hex), 2)]
# frame_bytes = [int(frame_hex[i:i+2], 16) for i in range(0, len(frame_hex), 2)]

# cal_params = extract_parameters(eeprom_bytes)
# ta = getTa(frame_bytes, cal_params)
# print("Ambient Temperature (Ta):", ta)

# grid = calculate_pixels(frame_bytes, cal_params, ta)

# for row in grid:
#     print(" ".join(f"{temp:.2f}" for temp in row))


# # plt.figure(figsize=(8,6))
# # plt.imshow(grid, cmap='inferno')  # thermal colormap
# # plt.colorbar(label='Temperature (Â°C)')
# # plt.title('MLX90640 Thermal Image')
# # plt.show()


# # grid_min = np.min(grid)
# # grid_max = np.max(grid)
# # normalized = ((grid - grid_min) / (grid_max - grid_min) * 255).astype(np.uint8)

# # # Resize to larger image for better visualization
# # thermal_img = cv2.resize(normalized, (320, 240), interpolation=cv2.INTER_NEAREST)

# # # Apply colormap
# # thermal_colored = cv2.applyColorMap(thermal_img, cv2.COLORMAP_INFERNO)

# # # Display
# # cv2.imshow("Thermal Image", thermal_colored)
# # cv2.waitKey(0)
# # cv2.destroyAllWindows()

# # # Save as PNG
# # cv2.imwrite("thermal_image.png", thermal_colored)
# # 'grid' is your 24x32 temperature array
# # Set threshold for hotspot (e.g., 40Â°C)
# hotspot_threshold = 26.0  

# # Create a mask: only keep values above threshold
# hotspot_mask = np.where(grid >= hotspot_threshold, grid, 0)

# # Normalize masked values to 0-255 for visualization
# masked_min = np.min(hotspot_mask)
# masked_max = np.max(hotspot_mask) if np.max(hotspot_mask) != 0 else 1  # avoid div0
# normalized = ((hotspot_mask - masked_min) / (masked_max - masked_min) * 255).astype(np.uint8)

# # Resize for better visibility
# thermal_img = cv2.resize(normalized, (320, 240), interpolation=cv2.INTER_NEAREST)

# # Apply colormap (hotspots visible, rest dark)
# thermal_colored = cv2.applyColorMap(thermal_img, cv2.COLORMAP_INFERNO)

# # Display image
# cv2.imshow("Hotspots", thermal_colored)
# cv2.waitKey(0)
# cv2.destroyAllWindows()

# # Save image
# cv2.imwrite("thermal_hotspots.png", thermal_colored)

import cv2
import numpy as np
from playsound import playsound
import tensorflow as tf

model = tf.keras.models.load_model("fire_detection_model.h5")
cap = cv2.VideoCapture(0)

# # Define fire-like HSV color range
# lower_fire = np.array([18, 50, 50])
# upper_fire = np.array([35, 255, 255])

# cap = cv2.VideoCapture(0)
# alarm_triggered = False

# while True:
#     ret, frame = cap.read()
#     if not ret:
#         break
#     hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)
#     mask = cv2.inRange(hsv, lower_fire, upper_fire)
#     contours, _ = cv2.findContours(mask, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)
#     for contour in contours:
#         area = cv2.contourArea(contour)
#         if area > 1000: # Fire detection threshold
#             x, y, w, h = cv2.boundingRect(contour)
#             cv2.rectangle(frame, (x, y), (x+w, y+h), (0, 0, 255), 2)
#             cv2.putText(frame, "ðŸ”¥ FIRE DETECTED!", (10, 40), cv2.FONT_HERSHEY_SIMPLEX, 1, (0, 0, 255), 3)
#             # if not alarm_triggered:
#             #     playsound('fire_alarm.mp3', block=False)
#             #     alarm_triggered = True


#     cv2.imshow('Fire Detection', frame)
#     if cv2.waitKey(1) & 0xFF == ord('q'):
#         break
while True:
    ret, frame = cap.read()
    img = cv2.resize(frame, (224, 224))
    img = img / 255.0
    img = img.reshape(1, 224, 224, 3)

    prediction = model.predict(img)
    label = "FIRE" if prediction[0] > 0.5 else "SAFE"

    color = (0, 0, 255) if label == "FIRE" else (0, 255, 0)
    cv2.putText(frame, label, (10, 40), cv2.FONT_HERSHEY_SIMPLEX, 1, color, 3)

    cv2.imshow("Fire Detection - AI", frame)
    if cv2.waitKey(1) & 0xFF == ord('q'):
        break
cap.release()
cv2.destroyAllWindows()

print("Program ended"  )
print("Program ended")  
print("Program ended")
print("Program ended")  
